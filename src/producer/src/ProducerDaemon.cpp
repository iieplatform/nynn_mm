// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <nynn_mm_graph_table.h>
#include <nynn_mm_config.h>
#include <Producer.h>
#include <ProviderRPC.h>

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/concurrency/Thread.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/server/TNonblockingServer.h>


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

using namespace  ::nynn::mm;
using namespace nynn::mm::rpc;
boost::shared_ptr<GraphTable> graphTable;
boost::shared_ptr<RWLock>     graphTableRWLock;
int provPort=0;

vector<string>& getHosts(GraphTable*gt,uint32_t vtxno, vector<string>& hosts)
{
	ExclusiveSynchronization es(graphTableRWLock.get());
  	uint32_t sgkey=SubgraphSet::VTXNO2SUBGRAPH(vtxno);
	gt->getHosts(sgkey,hosts);
	if (!hosts.empty())return hosts;

	gt->create(sgkey);
	gt->getHosts(sgkey,hosts);
	for (int i=0;i<hosts.size();i++){
		ProviderRPC prov(hosts[i],provPort);
		prov.createSubgraph(sgkey);
		prov.attachSubgraph(sgkey);
	}
}

class LockVertex{
public:
	LockVertex(ProviderRPC& prov,uint32_t vtxno):m_prov(prov),m_vtxno(vtxno)
	{
		m_prov.lock(vtxno,IS_WRITABLE|IS_BLOCKING);
	}
	~LockVertex()
	{
		m_prov.unlock(m_vtxno);
	}
private:
	ProviderRPC& m_prov;
	uint32_t m_vtxno;	
};

#if 1
class AttachSG{
public:
#if 1
	AttachSG(ProviderRPC& prov,uint32_t sgkey):m_prov(prov),m_sgkey(sgkey)
	{
		m_prov.attachSubgraph(m_sgkey);
	}
#endif
	~AttachSG()
	{
		m_prov.detachSubgraph(m_sgkey);
	}
private:
	ProviderRPC& m_prov;
	uint32_t m_sgkey;
};
#endif 
class ProducerHandler : virtual public ProducerIf {
 public:
  ProducerHandler() {
    // Your initialization goes here
  }

  bool report(const std::vector<int32_t> & sgkeys, const std::string& host) {
	  ExclusiveSynchronization es(graphTableRWLock.get());
	  vector<uint32_t> usgkeys(sgkeys.begin(),sgkeys.end()); 
	  graphTable->setAllSgkeys(host,usgkeys);
	  return true;
  }

  void getHost(std::string& host, const int32_t sgkey) {
	  SharedSynchronization ss(graphTableRWLock.get());
	  host=graphTable->getHost(sgkey);
  }

  int32_t insertPrev(const int32_t vtxno, const int32_t nextBlkno, const std::vector<int8_t> & xblk) { 
	  vector<string> hosts;
	  getHosts(graphTable.get(),vtxno,hosts);

	  uint32_t blkno=INVALID_BLOCKNO;
	  for (int i=0;i<hosts.size();i++){
		  ProviderRPC prov(hosts[i],provPort);
		  LockVertex lockv(prov,vtxno);
		  if ((blkno=prov.insertPrev(vtxno,nextBlkno,xblk))==INVALID_BLOCKNO)return INVALID_BLOCKNO;
	  }
	  return blkno;
  }

  int32_t insertNext(const int32_t vtxno, const int32_t prevBlkno, const std::vector<int8_t> & xblk) {
	  vector<string> hosts;
	  getHosts(graphTable.get(),vtxno,hosts);

	  uint32_t blkno=INVALID_BLOCKNO;
	  for (int i=0;i<hosts.size();i++){
		  ProviderRPC prov(hosts[i],provPort);
		  LockVertex lockv(prov,vtxno);
		  if ((blkno=prov.insertNext(vtxno,prevBlkno,xblk))==INVALID_BLOCKNO)return INVALID_BLOCKNO;
	  }
	  return blkno;
  }

  bool remove(const int32_t vtxno, const int32_t blkno) {
	  vector<string> hosts;
	  getHosts(graphTable.get(),vtxno,hosts);
	  uint32_t ret=INVALID_BLOCKNO;
	  for (int i=0;i<hosts.size();i++){
		  ProviderRPC prov(hosts[i],provPort);
		  LockVertex lockv(prov,vtxno);
		  if (!prov.remove(vtxno,blkno))return false;
	  }
	  return true;
  }

  int32_t unshift(const int32_t vtxno, const std::vector<int8_t> & newHeadXBlk) {
	  vector<string> hosts;
	  getHosts(graphTable.get(),vtxno,hosts);
	  uint32_t blkno=INVALID_BLOCKNO;
	  for (int i=0;i<hosts.size();i++){
		  ProviderRPC prov(hosts[i],provPort);
		  LockVertex lockv(prov,vtxno);
		  if ((blkno=prov.unshift(vtxno,newHeadXBlk))==INVALID_BLOCKNO)return INVALID_BLOCKNO;
	  }
	  return blkno;
  }

  bool shift(const int32_t vtxno) {
	  vector<string> hosts;
	  getHosts(graphTable.get(),vtxno,hosts);

	  for (int i=0;i<hosts.size();i++){
		  ProviderRPC prov(hosts[i],provPort);
		  LockVertex lockv(prov,vtxno);
		  if (!prov.shift(vtxno))return false;
	  }
	  return true;
  }

  int32_t push(const int32_t vtxno, const std::vector<int8_t> & newTailXBlk) {
	  vector<string> hosts;
	  getHosts(graphTable.get(),vtxno,hosts);
	  uint32_t blkno=INVALID_BLOCKNO;
	  for (int i=0;i<hosts.size();i++){
		  ProviderRPC prov(hosts[i],provPort);
		  LockVertex lockv(prov,vtxno);

		  if ((blkno=prov.push(vtxno,newTailXBlk))==INVALID_BLOCKNO)return INVALID_BLOCKNO;
	  }
	  return blkno;
  }

  bool pop(const int32_t vtxno) {
	  vector<string> hosts;
	  getHosts(graphTable.get(),vtxno,hosts);

	  for (int i=0;i<hosts.size();i++){
		  ProviderRPC prov(hosts[i],provPort);
		  LockVertex lockv(prov,vtxno);
		  if (!prov.pop(vtxno))return false;
	  }
	  return true;
  }
};

int main(int argc, char **argv) {
	
	int prodPort =strtoul(getenv("PRODUCER_PORT"),NULL,0);
	string provConf=getenv("PROVIDER_CONF");
	ifstream fin(provConf);
	vector<string> hosts;
	gettuple(fin,hosts);
	int replica=strtoul(getenv("REPLICA"),NULL,0);
	graphTable.reset(new GraphTable(hosts,replica));
	graphTableRWLock.reset(new RWLock);
	provPort=strtoul(getenv("PROVIDER_PORT"),NULL,0);

	boost::shared_ptr<ProducerHandler> handler(new ProducerHandler());
	boost::shared_ptr<TProcessor> processor(new ProducerProcessor(handler));
	//boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(prodPort));
	boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
	boost::shared_ptr<ThreadFactory> pthreadFactory(new PosixThreadFactory());

	boost::shared_ptr<ThreadManager> threadManager=ThreadManager::newSimpleThreadManager(10,4);
	threadManager->threadFactory(pthreadFactory);

	TNonblockingServer server(processor,transportFactory,transportFactory,protocolFactory,protocolFactory,prodPort,threadManager);
	threadManager->start();
	server.serve();
	return 0;
}

