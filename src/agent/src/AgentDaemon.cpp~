// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Agent.h"
#include<nynn_mm_config.h>
#include<nynn_mm_graph.h>

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/concurrency/Thread.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/server/TNonblockingServer.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;


using boost::shared_ptr;

using namespace  ::nynn::mm;
boost::shared_ptr<Graph> graph;
int prodPort=0;
int provPort=0;
int agentPort=0;
class AgentHandler : virtual public AgentIf {
 public:
  AgentHandler() {
    // Your initialization goes here
  }

  bool lock(const int32_t vtxno) {
	  return graph->lock(vtxno,false);
  }

  bool unlock(const int32_t vtxno) {
	  return graph->unlock(vtxno);
  }

  int32_t getHeadBlkno(const int32_t vtxno) {
	  return graph->getHeadBlkno(vtxno);
  }

  int32_t getTailBlkno(const int32_t vtxno) {
	  return graph->getTailBlkno(vtxno);
  }

  void read(std::vector<int8_t> & xblk, const int32_t vtxno, const int32_t blkno) {
	  graph->read(vtxno,blkno,xblk);
  }

};

int main(int argc, char **argv) {
	
	string prodHost=getenv("PRODUCER_HOST");
	string localHost=gethost();
	prodPort =strtoul(getenv("PRODUCER_PORT"),NULL,0);
	provPort =strtoul(getenv("PROVIDER_PORT"),NULL,0);
	agentPort =strtoul(getenv("AGENT_PORT"),NULL,0);
	string provConf=getenv("PROVIDER_CONF");
	ifstream fin(provConf);
	vector<string> hosts;
	gettuple(fin,hosts);
	graph.reset(new Graph(prodHost,prodPort,localHost,provPort,hosts));

	boost::shared_ptr<AgentHandler> handler(new AgentHandler());
	boost::shared_ptr<TProcessor> processor(new AgentProcessor(handler));
	//boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
	boost::shared_ptr<ThreadFactory> pthreadFactory(new PosixThreadFactory());

	boost::shared_ptr<ThreadManager> threadManager=ThreadManager::newSimpleThreadManager(10,4);
	threadManager->threadFactory(pthreadFactory);

	TNonblockingServer server(processor,transportFactory,transportFactory,protocolFactory,protocolFactory,agentPort,threadManager);
	threadManager->start();
	server.serve();
	return 0;
}

